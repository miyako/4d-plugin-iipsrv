/* --------------------------------------------------------------------------------
 #
 #	4DPlugin.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : iipsrv
 #	author : miyako
 #	2018/06/29
 #
 # --------------------------------------------------------------------------------*/


#include "4DPluginAPI.h"
#include "4DPlugin.h"

#define VERSION "0.1"

/* use globals as proxies for environment variables */

namespace iip
{
	unsigned int OPT_VERBOSITY;
	std::string OPT_LOGFILE;
	double OPT_MAX_IMAGE_CACHE_SIZE;
	std::string OPT_FILENAME_PATTERN;
	double OPT_JPEG_QUALITY;
	unsigned int OPT_MAX_CVT;
	unsigned int OPT_MAX_LAYERS;
	std::string OPT_FILESYSTEM_PREFIX;
	std::string OPT_WATERMARK;
	double OPT_WATERMARK_PROBABILITY;
	double OPT_WATERMARK_OPACITY;
	std::string OPT_LIBMEMCACHED_SERVERS;
	unsigned int OPT_LIBMEMCACHED_TIMEOUT;
	unsigned int OPT_INTERPOLATION;
	std::string OPT_CORS;
	std::string OPT_BASE_URL;
	std::string OPT_CACHE_CONTROL;
	bool OPT_ALLOW_UPSCALING;
	std::string OPT_URI_MAP;
	bool OPT_EMBED_ICC;
	
	std::mutex envMutex;
}

namespace iip
{
	char *tz = NULL;
	Timer request_timer;

	Cache *tileCache = NULL;
	std::mutex tileCacheMutex;
	
	imageCacheMapType *imageCache = NULL;
	std::mutex imageCacheMutex;
	
	std::map<std::string, std::string> uri_map;
	std::mutex uriMapMutex;

	/* because OpenJPEG is not thread safe */
	std::mutex openJPEGMutex;
}

void initClock()
{
	iip::tz = getenv("TZ");
	setenv("TZ","",1);
	tzset();
	
	srand(iip::request_timer.getTime());
	iip::request_timer.start();
}

void resetClock()
{
	if(iip::tz) setenv("TZ", iip::tz, 1);
	else unsetenv("TZ");
	tzset();
}

void OnStartup()
{
	initClock();

	syncEnv();
}

void startCache()
{
	std::lock_guard<std::mutex> guard(iip::tileCacheMutex);
	
	if(!iip::tileCache)
	{
		iip::tileCache = new Cache(iip::OPT_MAX_IMAGE_CACHE_SIZE);
	}
	
	if(1)
	{
		std::lock_guard<std::mutex> guard(iip::imageCacheMutex);
		
		if(!iip::imageCache)
		{
			iip::imageCache = new imageCacheMapType;
		}
	}
}

void clearCache()
{
	std::lock_guard<std::mutex> guard(iip::tileCacheMutex);

	if(iip::tileCache)
	{
		delete iip::tileCache;
		iip::tileCache = NULL;
	}
	
	if(1)
	{
		std::lock_guard<std::mutex> guard(iip::imageCacheMutex);
		
		if(iip::imageCache)
		{
			delete iip::imageCache;
			iip::imageCache = NULL;
		}
	}
}

void initURIMap()
{
	std::lock_guard<std::mutex> guard(iip::uriMapMutex);
	
	using namespace std;
	
	iip::uri_map.clear();
	
	// Setup our URI mapping for non-CGI requests
	if( !iip::OPT_URI_MAP.empty() )
	{
		// Check map is well-formed: maps must be of the form "prefix=>protocol"
		size_t pos;
		if( (pos = iip::OPT_URI_MAP.find("=>")) != string::npos )
		{
			// Extract protocol
			string prefix = iip::OPT_URI_MAP.substr( 0, pos );
			string protocol = iip::OPT_URI_MAP.substr( pos+2 );
			bool supported_protocol = false;
			
			// Make sure the command is one of our supported protocols: "IIP", "IIIF", "Zoomify", "DeepZoom"
			string prtcl = protocol;
			transform( prtcl.begin(), prtcl.end(), prtcl.begin(), ::tolower );
			if( prtcl == "iip" || prtcl == "iiif" || prtcl == "zoomify" || prtcl == "deepzoom" )
			{
				supported_protocol = true;
			}
			
			// IIP protocol requires "FIF" as first argument
			if( prtcl == "iip" ) prtcl = "fif";
			
			// Initialize our map
			if( supported_protocol ) iip::uri_map[prefix] = prtcl;
		}
	}
}

void OnExit()
{
	resetClock();
	
	clearCache();
}

void PluginMain(PA_long32 selector, PA_PluginParameters params)
{
	try
	{
		PA_long32 pProcNum = selector;
		sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
		PackagePtr pParams = (PackagePtr)params->fParameters;

		CommandDispatcher(pProcNum, pResult, pParams); 
	}
	catch(...)
	{

	}
}

void CommandDispatcher (PA_long32 pProcNum, sLONG_PTR *pResult, PackagePtr pParams)
{
	switch(pProcNum)
	{
		case kInitPlugin :
		case kServerInitPlugin :
			OnStartup();
			break;
			
		case kDeinitPlugin :
			OnExit();
			break;
			
			// --- iipsrv
			
		case 1 :
			IIPImage_Server(pResult, pParams, false, false);
			break;
			
		case 2 :
			IIPImage_Get_cache_info(pResult, pParams);
			break;
			
			// --- Time
			
		case 3 :
			Convert_time_rfc_to_iso(pResult, pParams);
			break;
			
			// --- iipsrv
			
		case 4 :
			IIPImage_SET_OPTION(pResult, pParams);
			break;
			
		case 5 :
			IIPImage_Get_option(pResult, pParams);
			break;
			
		case 6 :
			IIPImage_Server(pResult, pParams, true, false);
			break;
			
		case 7 :
			IIPImage_Server(pResult, pParams, false, true);
			break;
			
	}
}

// ------------------------------------ iipsrv ------------------------------------

bool PA_CreateArrayUnicodeVariable(PA_Variable *variable)
{
 /* safe ver. */
	
	PA_Unichar *uchar = (PA_Unichar *)"\0\0\0";
	variable->fType = (char) eVK_ArrayUnicode;
	variable->fFiller = 0;
	variable->uValue.fArray.fCurrent = 0;
	variable->uValue.fArray.fData = PA_NewHandle(sizeof(PA_Unistring));

	if(eER_NoErr == PA_GetLastError())
	{
		/* -10530 in preemptive mode c.f. ACI0098388 */
		variable->uValue.fArray.fNbElements = 0;
		char *pt = PA_LockHandle(variable->uValue.fArray.fData);
		if (pt)
		{
			*(PA_Unistring *) pt = PA_CreateUnistring(uchar);
			PA_UnlockHandle(variable->uValue.fArray.fData);
			return true;
		}
	}
	return false;
}

bool PA_CreateBlobVariable(PA_Variable *variable)
{
 /* safe ver. */
	
	variable->fType = (char) eVK_Blob;
	variable->fFiller = 0;
	variable->uValue.fBlob.fSize = 0;
	variable->uValue.fBlob.fHandle = PA_NewHandle(0);
	
	if(eER_NoErr == PA_GetLastError())
	{
		/* -10530 in preemptive mode c.f. ACI0098388 */
			return true;
	}
	return false;
}

std::string setSessionHeaders(Session *session,
															PA_Variable *names,
															PA_Variable *values)
{
	using namespace std;
	
	string request_uri;
	
	PA_long32 header_count = PA_GetArrayNbElements(*names);
	
	for(uint8_t i = 0; i <= header_count; ++i)
	{
		PA_Unistring str = PA_GetStringInArray(*names, i);
		CUTF8String name, value;
		C_TEXT t;
		t.setUTF16String(&str);
		t.copyUTF8String(&name);
		
		for (auto & c: name) c = toupper(c);
		
		str = PA_GetStringInArray(*values, i);
		t.setUTF16String(&str);
		t.copyUTF8String(&value);
		
		if(0 == name.find((const uint8_t *)"X-URL"))
		{
			request_uri = string((const char *)value.c_str());
		}
		session->headers[(const char *)name.c_str()] = string((const char *)value.c_str());
	}
	
	return request_uri;
}

void IIPImage_Server(sLONG_PTR *pResult, PackagePtr pParams, bool key_only, bool image_only)
{
	startCache();
	
	unsigned int flags = 1;/* IIP_USE_OPENJPEG */
		
	using namespace std;

	string version = VERSION;
	int loglevel;
	ofstream logfile;
	
	string waterMark;
	double waterMarkProbability;
	double waterMarkOpacity;
	
	double jpegQuality;
	unsigned int maxCVT;
	unsigned int maxLayers;
	bool allowUpscaling;
	bool embedICC;
	string cors;
	string cacheControl;
	string key;

	if(1)
	{
		std::lock_guard<std::mutex> guard(iip::envMutex);
		
		logfile.open(iip::OPT_LOGFILE.c_str(), std::ios::app);
		loglevel = iip::OPT_VERBOSITY;
		
		waterMark = iip::OPT_WATERMARK;
		waterMarkProbability = iip::OPT_WATERMARK_OPACITY;
		waterMarkOpacity = iip::OPT_WATERMARK_PROBABILITY;
		
		jpegQuality = iip::OPT_JPEG_QUALITY;
		maxCVT = iip::OPT_MAX_CVT;
		maxLayers = iip::OPT_MAX_LAYERS;
		allowUpscaling = iip::OPT_ALLOW_UPSCALING;
		embedICC = iip::OPT_EMBED_ICC;
		cors = iip::OPT_CORS;
		cacheControl = iip::OPT_CACHE_CONTROL;
	}
	
	/* Try to load our watermark; set up our watermark object */
	Watermark watermark(waterMark,
											waterMarkProbability,
											waterMarkOpacity);
	if(!key_only)
	{
		if( watermark.getImage().length() > 0 )
		{
			watermark.init();
			
			if( watermark.isSet() )
			{
				
			}
		}
	}
	
	/* instead of FileWriter/FCGIWriter */
	vector<uint8_t>writer;
	
	Task* task = NULL;
	
	// Declare our image pointer here outside of the try scope
	//  so that we can close the image on exceptions
	IIPImage *image = NULL;
	JPEGCompressor jpeg( jpegQuality );
	
	// View object for use with the CVT command etc
	View view;
	if( maxCVT != -1 ) view.setMaxSize( maxCVT );
	if( maxLayers != 0 ) view.setMaxLayers( maxLayers );
	view.setAllowUpscaling( allowUpscaling );
	view.setEmbedICC( embedICC );
	
	// Create an IIPResponse object - we use this for the OBJ requests.
	// As the commands return images etc, they handle their own responses.
	IIPResponse response;
	response.setCORS( cors );
	response.setCacheControl( cacheControl );
	
	PA_Variable params[2];
	
	if(PA_CreateArrayUnicodeVariable(&params[0]))
	{
		if(PA_CreateArrayUnicodeVariable(&params[1]))
		{
			PA_ExecuteCommandByID/* EX_EXECUTE_COMMAND_BY_ID:threadSafe */(
																																		 CMU_WEB_GET_HTTP_HEADER,
																																		 params,
																																		 2
																																		 );
			try{
				
				// Set up our session data object
				Session session;
				session.imageCacheMutex = &iip::imageCacheMutex;
				session.openJPEGMutex = &iip::openJPEGMutex;
				session.key_only = key_only;
				session.image_only = image_only;
				session.image = &image;
				session.response = &response;
				session.view = &view;
				session.jpeg = &jpeg;
				session.loglevel = loglevel;
				session.logfile = &logfile;
				session.flags = flags;
				session.out = &writer;
				session.watermark = &watermark;
				session.headers.clear();
				session.imageCache = iip::imageCache;
				session.tileCache = iip::tileCache;
				
				string request_string;
				string request_uri = setSessionHeaders(&session, &params[0], &params[1]);
				
				if(1)
				{
					std::lock_guard<std::mutex> guard(iip::uriMapMutex);
					
					// If we have a URI prefix mapping, first test for a match between the map prefix string
					//  and the full REQUEST_URI variable
					if( !iip::uri_map.empty() )
					{
						string prefix = iip::uri_map.begin()->first;
						string command = iip::uri_map.begin()->second;
						
						// Try to find the prefix at the beginning of request URI
						// Note that the first character will always be "/"
						size_t len = prefix.length();
						if( (len==0) || (request_uri.find(prefix)==1) ){
							// This is indeed a mapped request, so map our prefix with the appropriate protocol
							unsigned int start = (len>0) ? len+2 : 1; // Add 2 to remove both leading and trailing slashes
							// Strip out any query string if we are in prefix mode
							size_t q = request_uri.find_first_of('?');
							unsigned int end = (q==string::npos) ? request_uri.length() : q;
							request_string = command + "=" + request_uri.substr( start, end-start );
							
						}
					}
				}
				
				if( request_string.empty() )
				{
					size_t q = request_uri.find_first_of('?');
					if(q != string::npos)
					{
						request_string = request_uri.substr(q+1);
					}
				}
				
				// Check that we actually have a request string
				if( request_string.empty() ){
					throw string( "QUERY_STRING not set" );
				}
				
				// Store some headers
				session.headers["QUERY_STRING"] = request_string;
				session.headers["BASE_URL"] = iip::OPT_BASE_URL;
				
				// Parse up the command list
				
				list < pair<string,string> > requests;
				list < pair<string,string> > :: const_iterator commands;
				
				Tokenizer izer( request_string, "&" );
				while( izer.hasMoreTokens() ){
					pair <string,string> p;
					string token = izer.nextToken();
					int n = token.find_first_of( "=" );
					p.first = token.substr( 0, n );
					p.second = token.substr( n+1, token.length() );
					if( p.first.length() && p.second.length() ) requests.push_back( p );
				}
				
				for( commands = requests.begin(); commands != requests.end(); commands++ ){
					
					string command = (*commands).first;
					string argument = (*commands).second;
					
					task = Task::factory( command );
					if( task )
					{
						task->run( &session, argument );
					}
					
					if( !task ){
						// Unsupported command error code is 2 2
						response.setError( "2 2", command );
					}
					
					// Delete our task
					if( task ){
						delete task;
						task = NULL;
					}
					
				}
				
				/* Make sure something has actually been sent to the client
				 If no response has been sent by now, we must have a malformed command
				 */
				if( (!response.imageSent()) && (!response.isSet()) ){
					// Malformed command syntax error code is 2 1
					response.setError( "2 1", request_string );
				}
				
				/* Once we have finished parsing all our OBJ and COMMAND requests
				 send out our response.
				 */
				if( response.isSet() ){
					
					outData_printf(&writer, response.formatResponse().c_str());
					
				}
				
				key = session.key;
			}
			
			/* Use this for sending various HTTP status codes
			 */
			catch(const int& code){
				
				string status;
				
				switch(code)
				{
					case 304:
						status = "Status: 304 Not Modified\r\nServer: iipsrv/" + version + "\r\n\r\n";
						outData_printf(&writer, status.c_str() );
						break;
					case 100:
						break;
					default:
						break;
				}
			}
			
			catch(const string& error){
				
				if( response.errorIsSet() ){
					
				}
				else
				{ /* the home page of iipsrv */
					outData_printf(&writer, response.getAdvert().c_str());
				}
				
			}
			
			/* Image file errors */
			catch(const file_error& error){
				string status = "Status: 404 Not Found\r\nServer: iipsrv/" + version +
				(response.getCORS().length() ? "\r\n" + response.getCORS() : "") +
				"\r\n\r\n" + error.what();
				outData_printf(&writer, status.c_str());
			}
			
			/* Parameter errors */
			catch(const invalid_argument& error){
				string status = "Status: 400 Bad Request\r\nServer: iipsrv/" + version +
				(response.getCORS().length() ? "\r\n" + response.getCORS() : "") +
				"\r\n\r\n" + error.what();
				outData_printf(&writer, status.c_str());
			}
			
			catch(...)
			{ /* the home page of iipsrv */
				outData_printf(&writer, response.getAdvert().c_str());
			}
			
			/* Do some cleaning up etc. here after all the potential exceptions
			 have been handled
			 */
			if(task)
			{
				delete task;
				task = NULL;
			}
			
			delete image;
			image = NULL;
			
			PA_ClearVariable(&params[1]);
		}
		PA_ClearVariable(&params[0]);
	}
	

	
	if(!key_only)
	{
		C_BLOB returnValue;/* http raw data */
		returnValue.setBytes((const uint8_t *)&writer[0], writer.size());
		returnValue.setReturn(pResult);
	}else
	{
		C_TEXT returnValue;/* cmd:key */
		returnValue.setUTF8String((const uint8_t *)key.c_str(), key.length());
		returnValue.setReturn(pResult);
	}
	
	if(logfile)
	{
		logfile.close();
	}
}

#pragma mark -

void IIPImage_Get_cache_info(sLONG_PTR *pResult, PackagePtr pParams)
{
	startCache();
	
	C_TEXT returnValue;
	
	JSONNODE *info = json_new(JSON_NODE);
	
	if(1)
	{
		std::lock_guard<std::mutex> guard(iip::tileCacheMutex);
		
		json_set_i_for_key(info, L"count", iip::tileCache->getNumElements());
		json_set_f_for_key(info, L"size", iip::tileCache->getMemorySize());
		json_set_f_for_key(info, L"maxSize", iip::tileCache->getMaxSize());
		json_set_f_for_key(info, L"tileSize", iip::tileCache->getTileSize());
	}

	JSONNODE *objects = json_new(JSON_ARRAY);
	
	if(1)
	{
		std::lock_guard<std::mutex> guard(iip::imageCacheMutex);
		
		for(auto i = iip::imageCache->begin(); i != iip::imageCache->end();++i)
		{
			JSONNODE *object = json_new(JSON_NODE);
			json_set_s_for_key(object, L"key", i->first.c_str());
			json_set_s_for_key(object, L"timestamp", i->second.getTimestamp().c_str());
			json_push_back(objects, object);
		}
	}
	
	json_set_name(objects, L"files");
	json_push_back(info, objects);
	
	json_stringify(info, returnValue);
	json_delete(info);
	
	returnValue.setReturn(pResult);
}

// ------------------------------------- Time -------------------------------------

#pragma mark -

void Convert_time_rfc_to_iso(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	
	tm mod_t;
	time_t t;
	
	CUTF8String u8;
	Param1.copyUTF8String(&u8);
	
	if(strptime((const char *)u8.c_str(), "%a, %d %b %Y %H:%M:%S %Z", &mod_t))
	{
		t = mktime(&mod_t);
		char strt[64];
		size_t len = strftime(strt, 64, "%FT%TZ", &mod_t);
		if(len)
		{
			returnValue.setUTF8String((const uint8_t *)strt, len);
		}
	}
	
	returnValue.setReturn(pResult);
}

#pragma mark -

void setIntEnv(char *name, JSONNODE *n)
{
	std::vector<char>buf(100);
	json_int_t value = json_as_int(n);
#if _WIN32
	sprintf_s((char *)&buf[0], 100, "%I64u", value);
	_putenv_s(name, (const char *)std::string(&buf[0]).c_str());
#else
	sprintf((char *)&buf[0], "%llu", value);
	setenv(name, (const char *)std::string(&buf[0]).c_str(), 1);
#endif
}

void setFloatEnv(char *name, JSONNODE *n)
{
	std::vector<char>buf(100);
	json_number value = json_as_float(n);
#if _WIN32
	sprintf_s((char *)&buf[0], 100, "%16.16lf", value);
	_putenv_s(name, (const char *)std::string(&buf[0]).c_str());
#else
	sprintf((char *)&buf[0], "%16.16lf", value);
	setenv(name, (const char *)std::string(&buf[0]).c_str(), 1);
#endif
}

void setStringEnv(char *name, JSONNODE *n)
{
	std::vector<char>buf(100);
	json_char *value = json_as_string(n);
	
	if(value)
	{
#if _WIN32
		std::wstring pstr = value;

		size_t size = strlen(name);
		
		int len = MultiByteToWideChar(CP_UTF8,
																	0,
																	name,
																	size,
																	NULL,
																	0);
		if(len)
		{
			std::vector<uint8_t> buf((len + 1) * sizeof(wchar_t));
			if(MultiByteToWideChar(CP_UTF8,
														 0,
														 name,
														 size, (LPWSTR)&buf[0],
														 len))
			{
				_wputenv_s((const wchar_t *)&buf[0], pstr.c_str());
			}
		}
#else
			size_t wlen = wcslen(value);
			CFStringRef str = CFStringCreateWithBytes(kCFAllocatorDefault,
																								(const UInt8 *)value,
																								wlen*sizeof(wchar_t),
																								kCFStringEncodingUTF32LE,
																								true);
			if(str)
			{
				std::string pstr = [str UTF8String];
				setenv(name, pstr.c_str(), 1);
				CFRelease(str);
			}
#endif
			
			json_free(value);
		}
	}

void setPathEnv(char *name, JSONNODE *n, bool isFolder = true)
{
	std::vector<char>buf(100);
	json_char *value = json_as_string(n);
	
	if(value)
	{
#if _WIN32
		std::wstring pstr = value;
		for (size_t i = 0; i < pstr.size(); ++i)
			if (pstr.at(i) == '\\')
				pstr.at(i) = L'/';
		
		if(isFolder)
		{
			if(pstr.size()) if(pstr.at(u.size() - 1) != L'\\') pstr += (const wchar_t *)L"\\";
		}
		
		size_t size = strlen(name);
		
		int len = MultiByteToWideChar(CP_UTF8,
																	0,
																	name,
																	size,
																	NULL,
																	0);
		if(len)
		{
			std::vector<uint8_t> buf((len + 1) * sizeof(wchar_t));
			if(MultiByteToWideChar(CP_UTF8,
														 0,
														 name,
														 size, (LPWSTR)&buf[0],
														 len))
			{
				_wputenv_s((const wchar_t *)&buf[0], pstr.c_str());
			}
		}
#else
		size_t wlen = wcslen(value);
		CFStringRef str = CFStringCreateWithBytes(kCFAllocatorDefault,
																							(const UInt8 *)value,
																							wlen*sizeof(wchar_t),
																							kCFStringEncodingUTF32LE,
																							true);
		if(str)
	 {
		 NSURL *u = (NSURL *)CFURLCreateWithFileSystemPath(kCFAllocatorDefault, str, kCFURLHFSPathStyle, false);
		 if(u)
		 {
			 NSString *path = (NSString *)CFURLCopyFileSystemPath((CFURLRef)u, kCFURLPOSIXPathStyle);
			 if(path)/* the trailing separator is removed here */
			 {
				 std::string pstr = [path UTF8String];
				 if(isFolder)
				 {
					 if(pstr.size()) if(pstr.at(pstr.size() - 1) != '/') pstr += (const char *)"/";
				 }
				 setenv(name, pstr.c_str(), 1);
				 [path release];
			 }
			 [u release];
		 }
		 CFRelease(str);
	 }
#endif
		
		json_free(value);
	}
}

void syncEnv()
{
	if(1)
	{
		std::lock_guard<std::mutex> guard(iip::envMutex);

		iip::OPT_VERBOSITY = Environment::getVerbosity();
		iip::OPT_LOGFILE = Environment::getLogFile();
		iip::OPT_MAX_IMAGE_CACHE_SIZE = Environment::getMaxImageCacheSize();
		iip::OPT_FILENAME_PATTERN = Environment::getFileNamePattern();
		iip::OPT_JPEG_QUALITY = Environment::getJPEGQuality();
		iip::OPT_MAX_CVT = Environment::getMaxCVT();
		iip::OPT_MAX_LAYERS = Environment::getMaxLayers();
		iip::OPT_FILESYSTEM_PREFIX = Environment::getFileSystemPrefix();
		iip::OPT_WATERMARK = Environment::getWatermark();
		iip::OPT_WATERMARK_PROBABILITY = Environment::getWatermarkProbability();
		iip::OPT_WATERMARK_OPACITY = Environment::getWatermarkOpacity();
		iip::OPT_LIBMEMCACHED_SERVERS = Environment::getMemcachedServers();
		iip::OPT_LIBMEMCACHED_TIMEOUT = Environment::getMemcachedTimeout();
		iip::OPT_INTERPOLATION = Environment::getInterpolation();
		iip::OPT_CORS = Environment::getCORS();
		iip::OPT_BASE_URL = Environment::getBaseURL();
		iip::OPT_CACHE_CONTROL = Environment::getCacheControl();
		iip::OPT_ALLOW_UPSCALING = Environment::getAllowUpscaling();
		iip::OPT_URI_MAP = Environment::getURIMap();
		iip::OPT_EMBED_ICC = Environment::getEmbedICC();
	}
	
	initURIMap();
}

void IIPImage_Get_option(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT returnValue;
	
	JSONNODE *option = json_new(JSON_NODE);

	if(1)
	{
		std::lock_guard<std::mutex> guard(iip::envMutex);
		
		json_set_i_for_key(option, L"VERBOSITY", iip::OPT_VERBOSITY);
		json_set_s_for_key(option, L"LOGFILE", iip::OPT_LOGFILE.c_str());
		json_set_f_for_key(option, L"MAX_IMAGE_CACHE_SIZE", iip::OPT_MAX_IMAGE_CACHE_SIZE);
		json_set_s_for_key(option, L"FILENAME_PATTERN", iip::OPT_FILENAME_PATTERN.c_str());
		json_set_f_for_key(option, L"JPEG_QUALITY", iip::OPT_JPEG_QUALITY);
		json_set_i_for_key(option, L"MAX_CVT", iip::OPT_MAX_CVT);
		json_set_i_for_key(option, L"MAX_LAYERS", iip::OPT_MAX_LAYERS);
		json_set_s_for_key(option, L"FILESYSTEM_PREFIX", iip::OPT_FILESYSTEM_PREFIX.c_str());
		json_set_s_for_key(option, L"WATERMARK", iip::OPT_WATERMARK.c_str());
		json_set_f_for_key(option, L"WATERMARK_PROBABILITY", iip::OPT_WATERMARK_PROBABILITY);
		json_set_f_for_key(option, L"WATERMARK_OPACITY", iip::OPT_WATERMARK_OPACITY);
		json_set_s_for_key(option, L"LIBMEMCACHED_SERVERS", iip::OPT_LIBMEMCACHED_SERVERS.c_str());
		json_set_i_for_key(option, L"LIBMEMCACHED_TIMEOUT", iip::OPT_LIBMEMCACHED_TIMEOUT);
		json_set_i_for_key(option, L"INTERPOLATION", iip::OPT_INTERPOLATION);
		json_set_s_for_key(option, L"CORS", iip::OPT_CORS.c_str());
		json_set_s_for_key(option, L"BASE_URL", iip::OPT_BASE_URL.c_str());
		json_set_s_for_key(option, L"CACHE_CONTROL", iip::OPT_CACHE_CONTROL.c_str());
		json_set_b_for_key(option, L"ALLOW_UPSCALING", iip::OPT_ALLOW_UPSCALING);
		json_set_s_for_key(option, L"URI_MAP", iip::OPT_URI_MAP.c_str());
		json_set_b_for_key(option, L"EMBED_ICC", iip::OPT_EMBED_ICC);
	}
	
	json_stringify(option, returnValue);
	json_delete(option);
	
	returnValue.setReturn(pResult);
}

void IIPImage_SET_OPTION(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	
	Param1.fromParamAtIndex(pParams, 1);
	
	JSONNODE *option = json_parse(Param1);
	
	if(option)
	{
		if (json_type(option) == JSON_NODE)
		{
			JSONNODE_ITERATOR i = json_begin(option);
			while (i != json_end(option))
			{
				json_char *name = json_name(*i);
				if (name)
				{
					if(0 == std::wstring(name).find(L"VERBOSITY"))
					{
						setIntEnv("VERBOSITY", *i);
						goto next_element;
					}
					if(0 == std::wstring(name).find(L"LOGFILE"))
					{
						setPathEnv("LOGFILE", *i, false);
						goto next_element;
					}
					if(0 == std::wstring(name).find(L"MAX_IMAGE_CACHE_SIZE"))
					{
						setFloatEnv("MAX_IMAGE_CACHE_SIZE", *i);
						clearCache();
						goto next_element;
					}
					if(0 == std::wstring(name).find(L"FILENAME_PATTERN"))
					{
						setStringEnv("FILENAME_PATTERN", *i);
						goto next_element;
					}
					if(0 == std::wstring(name).find(L"JPEG_QUALITY"))
					{
						setFloatEnv("JPEG_QUALITY", *i);
						goto next_element;
					}
					if(0 == std::wstring(name).find(L"MAX_CVT"))
					{
						setIntEnv("MAX_CVT", *i);
						goto next_element;
					}
					if(0 == std::wstring(name).find(L"MAX_LAYERS"))
					{
						setIntEnv("MAX_LAYERS", *i);
						goto next_element;
					}
					if(0 == std::wstring(name).find(L"FILESYSTEM_PREFIX"))
					{
						setPathEnv("FILESYSTEM_PREFIX", *i);
						goto next_element;
					}
					if(0 == std::wstring(name).find(L"WATERMARK_PROBABILITY"))
					{
						setFloatEnv("WATERMARK_PROBABILITY", *i);
						goto next_element;
					}
					if(0 == std::wstring(name).find(L"WATERMARK_OPACITY"))
					{
						setFloatEnv("WATERMARK_OPACITY", *i);
						goto next_element;
					}
					if(0 == std::wstring(name).find(L"WATERMARK"))
					{
						setPathEnv("WATERMARK", *i, false);
						goto next_element;
					}
					if(0 == std::wstring(name).find(L"LIBMEMCACHED_SERVERS"))
					{
						setStringEnv("MEMCACHED_SERVERS", *i);
						goto next_element;
					}
					if(0 == std::wstring(name).find(L"LIBMEMCACHED_TIMEOUT"))
					{
						setIntEnv("MEMCACHED_TIMEOUT", *i);
						goto next_element;
					}
					if(0 == std::wstring(name).find(L"INTERPOLATION"))
					{
						setIntEnv("INTERPOLATION", *i);
						goto next_element;
					}
					if(0 == std::wstring(name).find(L"CORS"))
					{
						setStringEnv("CORS", *i);
						goto next_element;
					}
					if(0 == std::wstring(name).find(L"BASE_URL"))
					{
						setStringEnv("BASE_URL", *i);
						goto next_element;
					}
					if(0 == std::wstring(name).find(L"CACHE_CONTROL"))
					{
						setStringEnv("CACHE_CONTROL", *i);
						goto next_element;
					}
					if(0 == std::wstring(name).find(L"URI_MAP"))
					{
						setStringEnv("URI_MAP", *i);
						initURIMap();
						goto next_element;
					}
					if(0 == std::wstring(name).find(L"ALLOW_UPSCALING"))
					{
						setIntEnv("ALLOW_UPSCALING", *i);
						goto next_element;
					}
					if(0 == std::wstring(name).find(L"EMBED_ICC"))
					{
						setIntEnv("EMBED_ICC", *i);
						goto next_element;
					}
					
				next_element:
					json_free(name);
				}
				++i;
			}
		}
		
		json_delete(option);
	}
	
	syncEnv();
}
